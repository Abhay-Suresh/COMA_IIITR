# Project Plan â€” COMA

### Team Members
* Amod
* Kartik
* Sudarshan

### Objective
Systematically evaluate classical and metaheuristic approaches for the 0/1 Knapsack problem, measuring solution optimality, execution time, and resource efficiency using datasets generated from the provided `knapsack_data_generator.py` script.

### Common Responsibilities
* Use the `knapsack_data_generator.py` script to produce reproducible instance sets as defined in `sample.ipynb`.
* Apply a consistent evaluation protocol: same dataset for all methods, record solution value, runtime, and memory use.
* Develop experiment notebooks, building on the analysis foundation in `sample.ipynb`, with clear visualization (value distribution, runtime vs problem size) and summary data (e.g., `numeric_summary.csv`).
* Maintain a shared Git repository with structured folders for `implementations/`, `experiments/`, `notebooks/`, as well as the dataset output structure (e.g., `knapsack_multisize_data/`).

### Work Division: 

**Amod**
* **Classical Approach:** Dynamic Programming (Exact Algorithm), Greedy Algorithm: Value-to-weight ratio heuristic
* **Metaheuristic:** Genetic Algorithm (GA)
* **Quantum:** Grover-based search optimization (Grover's Adversarial Search)


**Kartik**
* **Classical Approach:** Branch and Bound (Exact Algorithm), Greedy Algorithm: Value-based heuristic
* **Metaheuristic:** Ant Colony Optimization (ACO)
* **Quantum:** Quantum Approximate Optimization Algorithm (QAOA)

**Sudarshan**
* **Classical Approach:** Backtracking (Exact Algorithm), Greedy Algorithm: Weight-first heuristic
* **Metaheuristic:** Particle Swarm Optimization (PSO)
* **Quantum:** Quantum Annealing

### References for Quantum Optimization (Will be updated soon...)
* [QUBOs (QA, QAOA) (pennylane.ai)](https://pennylane.ai/qml/demos/tutorial_QUBO)
* [Intro to QAOA (pennylane.ai)](https://pennylane.ai/qml/demos/tutorial_qaoa_intro)
* [QAOA (quantum.cloud.ibm.com)](https://quantum.cloud.ibm.com/docs/en/tutorials/quantum-approximate-optimization-algorithm)
* [Solving Optimization Problems with Quantum Algorithms (youtube.com)](https://www.youtube.com/watch?v=RyRKmZ6A25k)
* [Grover Optimizer (qiskit.org)](https://qiskit-community.github.io/qiskit-optimization/tutorials/04_grover_optimizer.html)

### Solution Optimality Calculation

* **Reference value ($V_{known}$):**
    * For `n=100`, use exact DP and B&B to compute the exact optimal value per instance. Use this as $V_{known}$.
    * For `n=250` and `n=500`, where exact computation may be infeasible, take the **best-known value** defined as the maximum value found across all algorithms (DP, B&B) and all runs for that specific instance.
* **Per-instance aggregation:** If an algorithm is randomized, collapse its 3 runs on the same instance into summary stats (best, median, mean, std of $V_{run}$ and $gap$).

### Implementation Guidelines
* Maintain a common function interface for solvers: `fit(instance, timeout=None, seed=...) -> best_solution, best_value, logs`.
* Log random seeds, parameters, and iteration-level metrics for reproducibility.
* Store experiment results in JSON format with fields: `{method, parameters, seed, instance_file, best_value, runtime}`.
* Test correctness on small instances by comparing exact algorithm results like DP.

### Evaluation Protocol

#### Dataset Generation Parameters
The full dataset is generated using `knapsack_data_generator.py` as called by `sample.ipynb`. This results in **27 unique instances**. The specific parameters are:

* **Sizes (n):** `[100,250,500]`
* **Capacity Regimes (capacity\_ratio):** `[0.2, 0.5, 0.8]`
* **Data Varieties (Distributions):** `["uniform", "normal", "zipf"]` for both weights and values.
* **Total Instances:** 1 instance for each combination of (size, capacity\_ratio, distribution), for a total of $3 \times 3 \times 3 = 27$ instances.
* **Seeds:** A unique seed is generated for each instance, derived from `BASE_SEED = 20251018` (from `sample.ipynb`).
* **Value/Weight Ranges:**
    * `WEIGHT_RANGE = (1, 500)`
    * `VALUE_RANGE = (1, 1000)`
* **Correlation:** `correlation=None` (as set in `sample.ipynb`).

#### Testing Protocol
* **Instances:** Test all algorithms on the **27 unique instances** generated by `sample.ipynb`.
* **Algorithm runs:** For randomized algorithms (GA, ACO, PSO), perform **3 independent runs per instance** and record the RNG seed for each run.
* **Metrics to record:**
    * Solution quality: Optimality gap vs known best (see dedicated section for calculation details).
    * Runtime: Wall-clock execution time.
* **Data varieties:** Test algorithms on all three data-distribution types (uniform, normal, zipf). Record results separately per distribution type.